package node

import (
	"encoding/json"
	"fmt"
	"reflect"

	listersv1 "k8s.io/client-go/listers/core/v1"

	"github.com/openshift/library-go/pkg/operator/configobserver"
	"github.com/openshift/library-go/pkg/operator/resource/resourcemerge"
	"github.com/openshift/library-go/pkg/operator/v1helpers"
)

const (
	// static pod revision config maps used by installer controller to track
	// configs across different revisions
	revisionConfigMapName = "config"
	revisionConfigMapKey  = "config.yaml"
)

type revisionDiffProfileSuppressor struct {
	operatorClient  v1helpers.StaticPodOperatorClient
	configMapLister listersv1.ConfigMapNamespaceLister
	usedConfigPaths [][]string
}

// NewSuppressConfigUpdateUntilSameProfileFunc is used to create a conditional func (shouldSuppressConfigUpdatesFunc)
// that can be used by the latency profile config observer to determine if a new update to observedConfig should be rolled out or not.
// It uses a config map lister and status obtained from a static pod operator client to check if all active revisions on the cluster have
// common values for the required latency config paths or not. Config maps generated by installer controller
// are read in order to determine the current active static pod revision and compare observedConfig values from it.
func NewSuppressConfigUpdateUntilSameProfileFunc(
	operatorClient v1helpers.StaticPodOperatorClient,
	configMapLister listersv1.ConfigMapNamespaceLister,
	latencyConfigs []LatencyConfigProfileTuple,
) (f func() (bool, error)) {

	usedConfigPaths := make([][]string, len(latencyConfigs))
	for i, latencyConfig := range latencyConfigs {
		usedConfigPaths[i] = latencyConfig.ConfigPath
	}

	ret := revisionDiffProfileSuppressor{
		operatorClient:  operatorClient,
		configMapLister: configMapLister,
		usedConfigPaths: usedConfigPaths,
	}

	// creates an actual conditional fn that can be invoked each time config observer
	// intends to update observed config
	return ret.shouldSuppressConfigUpdates
}

func (s *revisionDiffProfileSuppressor) shouldSuppressConfigUpdates() (suppress bool, err error) {
	operatorSpec, operatorStatus, _, err := s.operatorClient.GetStaticPodOperatorState()
	if err != nil {
		return false, err
	}

	mergedConfigRaw, err := resourcemerge.MergeProcessConfig(
		nil,
		operatorSpec.OperatorSpec.ObservedConfig.Raw,
		operatorSpec.OperatorSpec.UnsupportedConfigOverrides.Raw,
	)
	if err != nil {
		return false, err
	}

	var mergedConfig map[string]interface{}
	err = json.Unmarshal(mergedConfigRaw, &mergedConfig)
	if err != nil {
		return false, err
	}
	mergedConfigPruned := configobserver.Pruned(mergedConfig, s.usedConfigPaths...)

	// Collect the unique set of revisions for all nodes in cluster
	uniqueRevisionMap := make(map[int32]bool)
	for _, nodeStatus := range operatorStatus.NodeStatuses {
		revision := nodeStatus.CurrentRevision
		uniqueRevisionMap[revision] = true
	}

	for revision := range uniqueRevisionMap {
		configMapNameWithRevision := fmt.Sprintf("%s-%d", revisionConfigMapName, revision)
		configMap, err := s.configMapLister.Get(configMapNameWithRevision)
		if err != nil {
			return false, err
		}

		// read observed config from current config map
		configData, ok := configMap.Data[revisionConfigMapKey]
		if !ok {
			return false, fmt.Errorf("could not find %s in %s config map from %s namespace", revisionConfigMapKey, configMap.Name, configMap.Namespace)
		}

		var currentConfig map[string]interface{}
		if err := json.Unmarshal([]byte(configData), &currentConfig); err != nil {
			return false, err
		}

		// prune the current config with only paths that is supposed to be monitored
		// and keep comparing with the current config, in case of mis match, suppress
		currentConfigPruned := configobserver.Pruned(currentConfig, s.usedConfigPaths...)
		if !reflect.DeepEqual(mergedConfigPruned, currentConfigPruned) {
			// suppress=true: when config values don't match
			return true, nil
		}
	}
	// suppress=false, when all config values are identical
	return false, nil
}
